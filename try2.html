<!DOCTYPE html>
<html>
<head>
    <title></title>
    <style>
    canvas {
        border:1px solid #d3d3d3;
        background-color: #000;
    }
</style>
</head>
<body onload="startGame()">
    <link href="https://fonts.googleapis.com/css?family=Orbitron" rel="stylesheet">
    <script type="text/javascript" src="objects.js"></script>
    <script>
        //need to remove finish line.
        let backgroundColor = 255;
        let gameOn = true;
        let switcher = true;
        function startGame() {
            myGameArea.start();
            myGamePiece = new component(28,36,"images/spaceship.png",(myGameArea.canvas.width/2), myGameArea.canvas.height * .95, "image");
            finishBorder = new component(myGameArea.canvas.width, 300, "rgb(255,255,255)" ,0,0,"gradient");
            //the finish line is what the gamePiece must actually crashWith() in order to win.
            finishline = new component(myGameArea.canvas.width,28,"transparent",0,0);
            score = new component("30px","Orbitron","white",15,myGameArea.canvas.height -30,"text");
        }

        //myGameArea.start uses this function to decide the update interval.
        function everyInterval(n){
            if((myGameArea.frameNo / n) % 1 == 0){return true;}
            return false;
        }
        //myGameArea.start calls this function every interval, as seen above.
        function updateGameArea(){
            myGameArea.clear();
            finishBorder.update();
            finishline.update();
            myGamePiece.newPos();
            myGamePiece.update();
            myGamePiece.moveAngle = 0;
            myGameArea.frameNo += 1;
            score.text = "SPEED: " + (Math.round(myGamePiece.speed * 1000,0));
            score.update();

            //displays instructions untill a key is hit
            displayInstructions();
            //makes obstacles and orients them 
            displayObstacles();
            //moves obscatacles across screen and destroys obstacles offscreen
            moveAndDestroyObstacles();
            //check if gamepiece crashed with obstacles, and if it has create explosion.
            checkCrash();
            //check if gamepiece has passed the finished line, and if it has create score.
            checkWin();
            //check for key stroke. To control the game. 
            checkKeyStroke();
            //make sure gamepiece doesn't go outside of canvas
            noOutOfBounds(); 
            changeFinishColor();           
        }
        
        function displayInstructions(){
            if(gameOn && myGamePiece.speed < 3){
                startText = new component("31px", "Orbitron", "fff", 8, myGameArea.canvas.height/3,"text");
                startText.text = "Press Up Arrow To Accelerate";
                startText.update();
            }
        }

        let displayObstacles = (function(){
            let obstacleOrginSide;
            return function(){
                //obstacles 
                if (myGameArea.frameNo == 1 || everyInterval(70)){
                    end = myGameArea.canvas.height - myGameArea.canvas.height * .20;
                    start = myGameArea.canvas.height - myGameArea.canvas.height * .90;
                    x = myGameArea.canvas.width;
                    y = Math.floor((Math.random() * end) + start);
                    let astroid = myGameArea.astroidType[Math.floor(Math.random()*myGameArea.astroidType.length)];

                    if(obstacleOrginSide){
                        //myGameArea.obstacles.push(new component(25,25, "white", x, y, 'turn'));
                        myGameArea.obstacles.push(new component(25,25,astroid,x,y,"image"));
                        obstacleOrginSide = !obstacleOrginSide;
                    } else {
                        //myGameArea.obstacles.push(new component(25,25, "white", -10, y, 'turn', "left"));
                        myGameArea.obstacles.push(new component(25,25,astroid, -10,y,"image","left"));
                        obstacleOrginSide = !obstacleOrginSide; 
                    }
                }
            };
        })();

        function moveAndDestroyObstacles(){
            //make them appear and move
            for (let i = 0; i < myGameArea.obstacles.length; i++) {
                if(myGameArea.obstacles[i].side == "left"){
                    myGameArea.obstacles[i].x += 1; 
                    myGameArea.obstacles[i].angle += .03;   
                } else{
                    myGameArea.obstacles[i].x += -1;
                    myGameArea.obstacles[i].angle += -.03;
                }

                myGameArea.obstacles[i].update();
                // delete obstacles that go offscreeen so our array doesn't get crazy long
                if(myGameArea.obstacles[i].offscreen()){
                    myGameArea.obstacles.splice(i,1);
                } 
            }
        }

        function checkCrash(){
            for(let i = 0; i < myGameArea.obstacles.length; i++) {
                if((gameOn) && myGamePiece.crashWith(myGameArea.obstacles[i])){
                    //myGameArea.stop();
                    
                    myGamePiece.width = 0;
                    myGamePiece.height = 0;
                    myGamePiece.speed = 0;
                    gameOn = !gameOn;
                    makeParticles(myGamePiece.x,myGamePiece.y);   
                }
                explosion();
            }
        }

        makeParticles = function(x,y){
            const numberOfParticles = 35;
            let particleAngle = 0;
            for (var i = 0; i < numberOfParticles; i++) {
                myGamePiece.particles.push(new component(5,5,"#fff",x,y,"explosion"));
            }
            for (var i = 0; i < myGamePiece.particles.length; i++) {
                particleAngle += 1;
                myGamePiece.particles[i].speed = Math.floor((Math.random()* 2) + 1);
                myGamePiece.particles[i].angle = particleAngle;
            }  
        }

        function explosion(){
            for (var j = 0; j < myGamePiece.particles.length; j++) {
                alpha = ((j-5) * 5)/(-100);
                myGamePiece.particles[j].newPos();
                myGamePiece.particles[j].update(alpha);
                if(myGamePiece.particles[j].offscreen()){
                    myGamePiece.particles.splice(j,1);
                }
            }
        }

        function calculateMultiplyer(multiplyer){
            return((multiplyer * 2)/(myGameArea.canvas.width/2)).toFixed(2);  
        }

        function checkWin(){
            // if(myGamePiece.y < 70){
            //     finishBorder.color = 'white';

                if(myGamePiece.y < 0 - myGamePiece.height){
                    // this just checks where along the x axis the game piece crosses the line. The player wants to cross line in the middle. This if statement below just makes sure the multplyer is >270 (canvas/2). becuase later calculateMuliplyer funtion turns the variable muliplyer into value of maximum two.
                    let multiplyer; 
                    if(myGamePiece.x > (myGameArea.canvas.width/2)){
                        multiplyer = (myGamePiece.x - myGameArea.canvas.width) * -1;
                    } else {
                        multiplyer = myGamePiece.x;
                    }
                    myGameArea.stop();
                    displaySpeed = new component("38px", "Orbitron", "fff", 8, 120,"text");
                    displaySpeed.text = "SPEED: " + (myGamePiece.speed * 1000).toFixed(0);
                    displaySpeed.update();
                    displayMultiplyer = new component("38px", "Orbitron", "fff", 8, 170 ,"text");
                    displayMultiplyer.text = "MULTIPLYER: " + calculateMultiplyer(multiplyer);
                    displayMultiplyer.update();
                    displayTotal = new component("38px", "Orbitron", "fff", 8, 220 ,"text");
                    displayTotal.text = "TOTAL SCORE: " + (calculateMultiplyer(multiplyer) * myGamePiece.speed*1000).toFixed(0);
                    displayTotal.update();
                    myGamePiece.speed = 0;
                    gameOn = !gameOn;
                }
            }
        

        function checkKeyStroke(){
            if(gameOn){
                myGamePiece.speed += .001;
                animateSpaceship("straight");
                // game controls
                if (myGameArea.keys && myGameArea.keys[37]) {
                    myGamePiece.moveAngle = -myGamePiece.speed;
                    animateSpaceship("right"); 
                }
                if (myGameArea.keys && myGameArea.keys[39]) {
                    myGamePiece.moveAngle = myGamePiece.speed;
                    animateSpaceship("left"); 
                }
                if (myGameArea.keys && myGameArea.keys[38] && (myGamePiece.speed < 3)) {
                    myGamePiece.speed += .03;
                    animateSpaceship("fullblast") }
                    if (myGameArea.keys && myGameArea.keys[40]) {myGamePiece.speed += -.01; }
                }
            }

            function noOutOfBounds(){
               if(myGamePiece.x < (myGameArea.canvas.width - myGameArea.canvas.width)){
                myGamePiece.x = (myGameArea.canvas.width - myGameArea.canvas.width);
                myGamePiece.speed -= .002;
            }
            if(myGamePiece.x > (myGameArea.canvas.width - myGamePiece.width)){
                myGamePiece.x = (myGameArea.canvas.width - myGamePiece.width);
                myGamePiece.speed -= .002;
            }
            if(myGamePiece.y > (myGameArea.canvas.height- myGamePiece.height)){
                myGamePiece.y = (myGameArea.canvas.height- myGamePiece.height);
                myGamePiece.speed -= .002;
            }

        }

        // arguments should be straight, right or left, fullblast
        function animateSpaceship(direction){
            if(myGameArea.frameNo%5==0){

                if(direction == "straight"){
                    myGamePiece.cropPosY = 0;
                    myGamePiece.cropPosX += myGamePiece.width;
                    if(myGamePiece.cropPosX > myGamePiece.width*2){
                        myGamePiece.cropPosX = 0;
                    }
                }
                if(direction == "left"){
                    myGamePiece.cropPosY = myGamePiece.height;
                    myGamePiece.cropPosX += myGamePiece.width;
                    if(myGamePiece.cropPosX > myGamePiece.width*2){
                        myGamePiece.cropPosX = 0;
                    }
                }
                if(direction == "right"){
                    myGamePiece.cropPosY = (myGamePiece.height*2);
                    myGamePiece.cropPosX += myGamePiece.width;
                    if(myGamePiece.cropPosX > myGamePiece.width*2){
                        myGamePiece.cropPosX = 0;
                    }
                }
                if(direction == "fullblast"){
                    myGamePiece.cropPosY = (myGamePiece.height*3);
                    myGamePiece.cropPosX += myGamePiece.width;
                    if(myGamePiece.cropPosX > myGamePiece.width*2){
                        myGamePiece.cropPosX = 0;
                    }
                }
            }
        }
        function changeFinishColor(){
            if(myGameArea.frameNo%7==0){
                backgroundColor += -1;
                finishBorder.color = "rgb(" + backgroundColor + "," + backgroundColor + ",255)";
                if(myGamePiece.speed >= 4.5 && myGameArea.frameNo%15==0){
                if(backgroundColor <= 0 && backgroundColor%2==0){
                    finishBorder.color = "white";
                }if(backgroundColor <= 0 && backgroundColor%2==1){
                    finishBorder.color = "rgb(255,0,0)";
                }
            }
        }
    }

    // "rgb(255," + backgroundColor + "," + backgroundColor + ")";



</script>

</body>
</html>
