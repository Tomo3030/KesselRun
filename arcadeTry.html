<!DOCTYPE html>
<html>
<head>
    <title></title>
    <style>
    canvas {
        border:1px solid #d3d3d3;
        background-color: #f1f1f1;
    }
</style>
</head>
<body onload="startGame()">
    <script>
        function startGame() {
            myGameArea.start();
            myGamePiece = new component(25,25,"red",(myGameArea.canvas.width/2), myGameArea.canvas.height * .95);
            //so here we have to take the canvas width * 2 because we divded by two during the rotation update. 
            finishLine = new component(myGameArea.canvas.width, 50, "blue",0,0);
            test = new component(10,10, "yellow", 100,0);
        }

        const myGameArea = {
            canvas : document.createElement('canvas'),
            start : function(){
                this.canvas.width = 480;
                this.canvas.height = 720;
                this.context = this.canvas.getContext("2d");
                document.body.insertBefore(this.canvas, document.body.childNodes[0]);
                this.frameNo = 0;
                this.interval = setInterval(updateGameArea, 20);
                //set Event listeners for controllers:
                window.addEventListener('keydown',function(e){
                    myGameArea.keys = (myGameArea.keys || []);
                    myGameArea.keys[e.keyCode] = true;
                })
                window.addEventListener('keyup', function(e){
                    myGameArea.keys[e.keyCode] = false;
                })
            },

            clear : function(){
                this.context.clearRect(0,0, this.canvas.width,this.canvas.height);
            }

        }

        function component(width, height, color, x, y){
            this.width = width;
            this.height = height;
            this.color = color;
            this.x = x;
            this.y = y;
            this.angle = 0;
            this.moveAngle = 0;
            this.speed = 0;
            
            this.update = function(){
                ctx = myGameArea.context;
                ctx.fillStyle = color;
                ctx.fillRect(this.x, this.y, this.width, this.height)
            }

            
            this.updateTurn = function(){
             ctx = myGameArea.context;
             ctx.save();
             ctx.translate(this.x, this.y);
             ctx.rotate(this.angle);
             ctx.fillStyle = color;
             ctx.fillRect(this.width / -2, this.height / -2, this.width, this.height);
             ctx.restore();  
         }

         this.newPos = function() {
            this.angle += this.moveAngle * Math.PI / 180;
            this.x += this.speed * Math.sin(this.angle);
            this.y -= this.speed * Math.cos(this.angle);
        }



        this.crashWith = function(obstacle){
            let myFront = this.y;
            let myBack = this.y - this.height;
            let myLeft = this.x;
            let myRight = this.x - this.width;

            let obstableFront = obstacle.y;
            let obstacleBack = obstacle.y = obstacle.height;
            let obstacleLeft = obstacle.x;
            let obstacleRight = obstacle.x - obstacle.width;
            
            let crash = false;

            if(myFront < obstacleBack){crash = true;}
            return crash; 
        }

        this.offscreen = function(){
            if(this.x < -this.width){
                return true;
            } else {
                return false;
            }
        }
    }

    function everyInterval(n){
        if((myGameArea.frameNo / n) % 1 == 0){return true;}
        return false;
    }


    function updateGameArea(){
        myGameArea.clear();
        finishLine.update();
        myGamePiece.newPos();
        myGamePiece.updateTurn();
        test.update();
        myGamePiece.moveAngle = 0;
        myGameArea.frameNo += 1;
            // create obstacles
            if (myGameArea.frameNo == 1 || everyInterval(70)){
                end = myGameArea.canvas.height - myGameArea.canvas.height * .20;
                start = myGameArea.canvas.height - myGameArea.canvas.height * .90;
                x = myGameArea.canvas.width;
                y = Math.floor((Math.random() * end) + start);
                y1 = Math.floor((Math.random() * end) + start);
                // make sure obstacles don't have same y value
                leftObstacles.push(new component(50,10, "green",x, y));
                rightObstacles.push(new component(50,10, "green",-20,y1));
            }
            //make them appear
            for (i = 0; i < leftObstacles.length; i++) {
                leftObstacles[i].x += -1;
                leftObstacles[i].update();
               // delete obstacles that go offscreeen so our array doesn't get crazy long
               if(leftObstacles[i].offscreen()){
                   leftObstacles.splice(i,1);
               } 
            }

            for (i = 0; i < rightObstacles.length; i++) {
                rightObstacles[i].x += +1;
                rightObstacles[i].update();
               // delete obstacles that go offscreeen so our array doesn't get crazy long
               if(rightObstacles[i].offscreen()){
                   rightObstacles.splice(i,1);
                }
            }
            // initial speed
            myGamePiece.speed = 0;
            // game controls
            if (myGameArea.keys && myGameArea.keys[37]) {myGamePiece.moveAngle = -2; }
            if (myGameArea.keys && myGameArea.keys[39]) {myGamePiece.moveAngle = 2; }
            if (myGameArea.keys && myGameArea.keys[38]) {myGamePiece.speed = 2; }
            if (myGameArea.keys && myGameArea.keys[40]) {myGamePiece.speed = -1; }
            // no out of bounds
            if(myGamePiece.x < (myGameArea.canvas.width - myGameArea.canvas.width)){
                myGamePiece.x = (myGameArea.canvas.width - myGameArea.canvas.width);
            }
            if(myGamePiece.x > (myGameArea.canvas.width - myGamePiece.width)){
                myGamePiece.x = (myGameArea.canvas.width - myGamePiece.width);
            }
            if(myGamePiece.y > (myGameArea.canvas.height- myGamePiece.height)){
                myGamePiece.y = (myGameArea.canvas.height- myGamePiece.height);
            }

        }        

    </script>

</body>
</html>
